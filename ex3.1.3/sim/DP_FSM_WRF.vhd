library ieee;
use ieee.std_logic_1164.all;
use ieee.math_real.all;
use work.constants.all;

-- ATTENTION: 	in the following design you will find the distinction 
-- 				between physical and virtual address. You should consider
--				the virtual address the one generated by the subroutine 
--				(i.e. the address "seen" from the programmer point of view), 
--				while the physical address is the real address, with the 
-- 				number of bits that depends on the real size of the register
--				file. Therefore the virtual address will be on less bits than
--				the physical one since the window, addressed by a subroutine,
--				is only a subset of registers respect to the real size of the
--				register file

entity DP_FSM_WRF is
	generic (
		F : integer := F_WRF; -- number of windows in the register file
		N : integer := N_WRF; -- number of registers per window (globals excluded)
		M : integer := M_WRF  -- numeber of global registers
		-- Address sizing:
		-- ceil(log2(real(3*N + M) + real(1))) is the address size for the virtual address, +1 to avoid rounding errors. e.g.: when value = 8s
		-- ceil(log2(real(2*N*F + M) + real(1))); -- is the address size for the physical address, +1 to avoid rounding errors. e.g.: when value = 8s
	);
	port (
		Clk : in std_logic;  -- clock signal

		-- input control signals
		load_reg_swp : in std_logic;  -- load signal for SWP register
		load_reg_cwp : in std_logic;  -- load signal for CWP register
		addr_virt_sel_port_1 : in std_logic;  -- control signal which selects RD1 or WR virtual address and drives it through a mux to the port 1 of the LUT
		rotL_swp : in std_logic;  -- rotation signals for SWP and CWP
		rotR_swp : in std_logic;
		rotL_cwp : in std_logic;
		rotR_cwp : in std_logic;
		load_reg_canreturn : in std_logic;  -- load signal for CANRETURN register
		load_reg_cansave : in std_logic;  -- load signal for CANSAVE register
		cansave_update_or : in std_logic;  -- update signals for CANSAVE and CANRETURN ... see CU_FSM_WRF for their behavior description
		cansave_update_and : in std_logic;
		canreturn_update_or : in std_logic;
		canreturn_update_and : in std_logic;
		en_rst_rom : in std_logic;  -- enable signal for the reset ROM, containing the reset values for CWP, SWP, CANSAVE, CANRETURN
		en_lut_rom : in std_logic;	-- anable signal for the LUT ROM, when active either the CWP or the SWP is driven as enable, otherwise zeroed-out by the and gate
		spill_fill_flag : in std_logic;  -- signal active when a fill or spill operation occurs
		cnt_upcnt : in std_logic;  -- signal which, when active, increases by 1 the counter status
		rst_upcnt : in std_logic;  -- signal which resets the up counter status (zeroed-out)
		fill_flag : in std_logic;

		-- output control signals
		can_return : out std_logic;  -- control signal that tells if a return needs (=0) a fill or not (=1)
		free : out std_logic;  -- control signal that tells if a call needs (=0) a spill or not (=1)
		TC_upcnt : out std_logic;  -- terminal count signal sent by the up counter 

		-- input data
		addr_virt_RD1 : in std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0); -- virtual address read port 1
		addr_virt_RD2 : in std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0); -- virtual address read port 2
		addr_virt_WR : in std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0); -- virtual address write

		-- output data
		addr_py_RD1 : out std_logic_vector(integer(ceil(log2(real(2*N*F + M) + real(1))))-1 downto 0); -- physical address read port 1
		addr_py_RD2 : out std_logic_vector(integer(ceil(log2(real(2*N*F + M) + real(1))))-1 downto 0); -- physical address read port 2
		addr_py_WR : out std_logic_vector(integer(ceil(log2(real(2*N*F + M) + real(1))))-1 downto 0) -- physical address write
	);
end entity;

architecture ARCHSTRUCT of DP_FSM_WRF is
	-- rotate register for CWP and SWP - configuration name: CFT_ARCHBEH_RotRegN
	component RotRegN is
		generic(
			N : integer := Nbit_RotReg
		);
		port(
			DataIn : in std_logic_vector(N-1 downto 0);	-- data input for the parallel load
			Clk : in std_logic;	-- clock signal
			Rst : in std_logic; -- reset signal
			Load : in std_logic;	-- parallel load enable signal
			RotL : in std_logic; -- rotate left by 1
			RotR : in std_logic;	-- rotate right by 1
			DataOut : out std_logic_vector(N-1 downto 0) -- output data
		);
	end component;


	-- LUT ROM for addresses translation - configuration name: CFG_LUT_ROM_ARCHBEH
	component LUT_ROM is
		generic (
			N : integer := N_WRF;
			F : integer := F_WRF;
			M : integer := M_WRF
		);
		port(
			Clk : in std_logic;
			addr1, addr2 : in std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0); -- address 
			en   : in std_logic_vector(F-1 downto 0); -- ROM Enable, for additiona
			dout1, dout2 : out std_logic_vector(integer(ceil(log2(real(2*N*F + M) + real(1))))-1 downto 0)
		);
	end component;


	-- updateReg for CANSAVE and CANRETURN - configuration name: CFG_ARCHSTRUCT_UpdateRegN
	component UpdateRegN is
		generic(
			N : integer := Nbit_UpdateRegN
		);
		port (
			load : in std_logic;								-- control signal for load the dataIn
			updateOR : in std_logic;							-- control signal to set = 1 a flag
			updateAND : in std_logic;							-- control signal to clear = 0 a flag
			Clk : in std_logic;
			dataIn : in std_logic_vector(N-1 downto 0);
			dataOut : out std_logic_vector(N-1 downto 0);
			updateVal : in std_logic_vector(N-1 downto 0)		-- it should be driven with CWP or SWP to set/clear a flag
		);
	end component;

	-- up counter - configuration name: CFG_ARCHSTRUCT_UPCNT
	component UpCntN is
		generic(
			N : integer := Nbit_UpCnt;
			maxVal : integer := MaxVal_UpCnt
		);
		port (
			Clk : in std_logic;
			Rst : in std_logic;
			cnt : in std_logic;
			Out_cnt : out std_logic_vector(N-1 downto 0);
			TC : out std_logic
		);
	end component;

	-- return check logic - configuration name: CFG_DF_RETURN_CHECK_LOGIC 
	component RETURN_CHECK_LOGIC is
		generic (
			N : integer := Nbit_return_check_logic -- width of the inputs
		);	
		port (
			CWP : in std_logic_vector(N-1 downto 0);		-- current window pointer
			SWP : in std_logic_vector(N-1 downto 0);		-- saved window pointer
			CANRESTORE : in std_logic_vector(N-1 downto 0); -- can restore window flags
			Can_return : out std_logic						-- Can_return = 1 means that a return subroutine doesn't require a fill from the main memory, 
		);													-- i.e. the previous window is the parent of the current one
	end component;

	-- call check logic - configuration name: CFG_DF_CALL_CHECK_LOGIC
	component CALL_CHECK_LOGIC is
		generic (
			N : integer := Nbit_call_check_logic -- width of the inputs
		);	
		port (
			CWP : in std_logic_vector(N-1 downto 0);		-- current window pointer
			CANSAVE : in std_logic_vector(N-1 downto 0);	-- can save window flags
			-- CANRESTORE : in std_logic_vector(N-1 downto 0); -- can restore window flags
			Free : out std_logic							-- Free = 1 means that the window is free and we can call without spill into the memory the registers 
		);													-- otherwise spill
	end component;

	-- reset rom - configuration name: CFG_ARCHDATAFLOW_RST_ROM
	component RST_ROM is
		generic(
			N : integer := Nbit_RST_ROM
		);
		port (
			en : in std_logic; -- enable signal
			SWP_rst_val : out  std_logic_vector(N-1 downto 0);
			CWP_rst_val : out  std_logic_vector(N-1 downto 0);
			CANSAVE_rst_val : out  std_logic_vector(N-1 downto 0);
			CANRETURN_rst_val : out  std_logic_vector(N-1 downto 0)
		);
	end component;

	-- mux - configuration name: CFG_MUXN1_ARCHSTRUCT
	component muxN1 is
		generic (N : integer := Nbit_MUXN1);
		port(
			A : 	in 		std_logic_vector(N-1 downto 0);	-- input A
			B : 	in 		std_logic_vector(N-1 downto 0);	-- input B
			S : 	in 		std_logic;						-- selection signal
			Y : 	out 	std_logic_vector(N-1 downto 0)	-- output
		);
	end component;

	-- andN - configuration name: CFG_ARCHDATAFLOW_and2N
	component and2N is
		generic(
			N : integer := 1	-- by default it is a 1-bit logic gate
		);
		port(
			A : in std_logic_vector(N-1 downto 0);
			B : in std_logic_vector(N-1 downto 0);
			Y : out std_logic_vector(N-1 downto 0)
		);
	end component;

	-- internal signals
	signal dataIn_CWP, dataOut_CWP, dataIn_SWP, dataOut_SWP : std_logic_vector(F-1 downto 0);
	signal out_mux_rd1_wr, out_mux_rd2_cntOut : std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0);
	signal out1_lut_rom, out2_lut_rom, out_mux_addr_py_1 : std_logic_vector(integer(ceil(log2(real(2*N*F + M) + real(1))))-1 downto 0);
	signal out_up_counter : std_logic_vector(integer(ceil(log2(real(3*N + M) + real(1))))-1 downto 0);
	signal cansave_rst_val_out, cansave_out, canreturn_rst_val_out, canreturn_out : std_logic_vector(F-1 downto 0);
	signal out_mux_en_lut_rom, out_mux_activ_en_lut_rom, out_and_en_lut_rom : std_logic_vector(F-1 downto 0);

begin
	
	CWP_reg : RotRegN
						generic map(
							N => F -- size equal to the number of windows in the windowed register file
						)
						port map(
							DataIn => dataIn_CWP, 
							Clk => Clk,
							Rst => '0', -- reset handled by RST_ROM
							Load => load_reg_cwp,
							RotL => rotL_cwp,
							RotR => rotR_cwp,
							DataOut => dataOut_CWP
						);

	SWP_reg : RotRegN
						generic map(
							N => F -- size equal to the number of windows in the windowed register file
						)
						port map(
							DataIn => dataIn_SWP, 
							Clk => Clk,
							Rst => '0', -- reset handled by RST_ROM
							Load => load_reg_swp,
							RotL => rotL_swp,
							RotR => rotR_swp,
							DataOut => dataOut_SWP
						);

	LUT_addresses : LUT_ROM 
						generic map(
							N => N,
							F => F,
							M => M
						)
						port map(
							Clk => Clk,
							addr1 => out_mux_rd1_wr,
							addr2 => out_mux_rd2_cntOut,
							en => out_and_en_lut_rom,
							dout1 => out1_lut_rom,
							dout2 => out2_lut_rom 
						);

	-- driving out1 of the LUT_ROM to both RD1 and WR output addresses
	addr_py_RD1 <= out1_lut_rom;
	addr_py_RD2 <= 	out2_lut_rom;
	addr_py_WR <= out_mux_addr_py_1;


	-- up counter for reading sequentially within a window all the registers (globals EXCLUDED)
	up_counter : UpCntN
						generic map(
							N => integer(ceil(log2(real(3*N + M) + real(1)))),
							maxVal => 2*N-1
						)
						port map(
							Clk => Clk,
							Rst => rst_upcnt,
							cnt => cnt_upcnt,
							Out_cnt => out_up_counter,
							TC => TC_upcnt
						);

	CANSAVE_reg : UpdateRegN
						generic map(
							N => F -- F bits, each one flag for one window
						)
						port map(
							load => load_reg_cansave,
							updateOR =>	cansave_update_or,		
							updateAND => cansave_update_and,
							Clk => Clk,
							dataIn => cansave_rst_val_out,
							dataOut => cansave_out,
							updateVal => dataOut_CWP
						);

	CANRETURN_reg : UpdateRegN
						generic map(
							N => F				
						)
						port map(
							load => load_reg_canreturn,
							updateOR =>	canreturn_update_or,		
							updateAND => canreturn_update_and,
							Clk => Clk,
							dataIn => canreturn_rst_val_out,
							dataOut => canreturn_out,
							updateVal => dataOut_SWP
						);

	reset_rom : RST_ROM
						generic map(
							N => F -- size of SWP, CWP, CANRETURN, CANSAVE
						)
						port map(
							en => en_rst_rom,
							SWP_rst_val => dataIn_SWP,
							CWP_rst_val => dataIn_CWP,
							CANSAVE_rst_val => cansave_rst_val_out,
							CANRETURN_rst_val => canreturn_rst_val_out
						);

	call_check : CALL_CHECK_LOGIC
						generic map(
							N => F -- number of windows is the width of CWP, SWP, CANSAVE and CANRESTORE registers
						)
						port map(
							CWP => dataOut_CWP,
							CANSAVE => cansave_out,
							-- CANRESTORE => canreturn_out,
							Free => free
						);

	return_check : RETURN_CHECK_LOGIC
						generic map(
							N => F -- number of windows is the width of CWP, SWP, CANSAVE and CANRESTORE registers
						)
						port map(
							CWP => dataOut_CWP,
							SWP => dataOut_SWP,
							CANRESTORE => canreturn_out,
							Can_return => can_return
						);

	mux_addr1_lut_rom_selection : muxN1 
						generic map(
							N => integer(ceil(log2(real(3*N + M) + real(1))))
						)
						port map(
							A => addr_virt_WR,  -- selected when S = 1
							B => addr_virt_RD1, -- selected when S = 0
							S => addr_virt_sel_port_1,
							Y => out_mux_rd1_wr  -- driving signal to port #1 of the LUT_ROM
						);

	mux_addr2_lut_rom_selection : muxN1 
						generic map(
							N => integer(ceil(log2(real(3*N + M) + real(1))))
						)
						port map(
							A => out_up_counter,  -- selected when S = 1
							B => addr_virt_RD2, -- selected when S = 0
							S => spill_fill_flag,
							Y => out_mux_rd2_cntOut  -- driving signal to port #1 of the LUT_ROM
						);

	mux_enable_lut_rom : muxN1
						generic map(
							N => F
						)
						port map(
							A => dataOut_SWP,  -- selected when S = 1
							B => dataOut_CWP, -- selected when S = 0
							S => spill_fill_flag,
							Y => out_mux_en_lut_rom  -- driving signal to port #1 of the LUT_ROM
						);

	mux_activation_enable_lut_rom : muxN1
						generic map(
							N => F
						)
						port map(
							A => (others => '1'),  -- selected when S = 1
							B => (others => '0'), -- selected when S = 0
							S => en_lut_rom,
							Y => out_mux_activ_en_lut_rom  -- driving signal to port #1 of the LUT_ROM
						);


	and_driving_en_lut_rom : and2N
						generic map(
							N => F
						)
						port map(
							A => out_mux_activ_en_lut_rom,
							B => out_mux_en_lut_rom,
							Y => out_and_en_lut_rom
						);

	mux_addr_fill_driving : muxN1
						generic map(
							N => integer(ceil(log2(real(2*N*F + M) + real(1))))
						)
						port map(
							A => out2_lut_rom,  -- selected when S = 1
							B => out1_lut_rom, -- selected when S = 0
							S => fill_flag,
							Y => out_mux_addr_py_1  -- driving signal to port #1 of the LUT_ROM
						);

end architecture;


configuration CFG_DP_FSM_WRF of DP_FSM_WRF is
	for ARCHSTRUCT

		for all : RotRegN
			use configuration work.CFT_ARCHBEH_RotRegN;
		end for;

		for all : LUT_ROM
			use configuration work.CFG_LUT_ROM_ARCHBEH;
		end for;

		for all : UpCntN
			use configuration work.CFG_ARCHSTRUCT_UPCNT;
		end for;

		for all : UpdateRegN
			use configuration work.CFG_ARCHSTRUCT_UpdateRegN;
		end for;

		for all : RST_ROM
			use configuration work.CFG_ARCHDATAFLOW_RST_ROM;
		end for;

		for all : CALL_CHECK_LOGIC
			use configuration work.CFG_DF_CALL_CHECK_LOGIC;
		end for;

		for all : muxN1 
			use configuration work.CFG_MUXN1_ARCHSTRUCT;
		end for;

		for all : and2N
			use configuration work.CFG_ARCHDATAFLOW_and2N;
		end for;

	end for;
end configuration;
